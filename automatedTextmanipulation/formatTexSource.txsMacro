{
    "abbrev": "format-tex-source",
    "description": [
        "Formats TeX source code by applying proper indentation, compressing multiple whitespace characters into one, etc."
    ],
    "formatVersion": 1,
    "menu": "",
    "name": "Format TeX source",
    "shortcut": "",
    "tag": [
        "%SCRIPT",
        "",
        "// Common utility functions",
        "",
        "fatal_error = function (message) {",
        "\tthrow (message);",
        "};",
        "",
        "// Class ParseNode. Represents one document node. Can be organized either in linear or tree form",
        "",
        "ParseNode = function (props) {",
        "\tvar i;",
        "",
        "\tfor (i in props) {",
        "\t\tthis [i] = props [i];",
        "\t}",
        "};",
        "ParseNode.prototype = {",
        "\taddChild: function (child) {",
        "\t\tif (('children' in this) == false) {",
        "\t\t\tfatal_error ('Cannot add a child to node of type: ' + this.type);",
        "\t\t}",
        "\t\tthis.children.push (child);",
        "\t}",
        "};",
        "// Each node type can be used in linear form, tree form or both",
        "ParseNode.typeComment = 1;\t// linear, tree",
        "ParseNode.typeEmptyLine = 2;\t// linear, tree",
        "ParseNode.typeEnv = 3;\t\t// tree",
        "ParseNode.typeEnvBegin = 4;\t// linear",
        "ParseNode.typeEnvEnd = 5;\t// linear",
        "ParseNode.typeRoot = 6;\t\t// tree",
        "ParseNode.typeText = 7;\t\t// linear, tree",
        "ParseNode.typeVerbatim = 8;\t// linear, tree",
        "ParseNode.createComment = function (text) {",
        "\treturn (new ParseNode ({type: ParseNode.typeComment, text: text}));",
        "};",
        "ParseNode.createEmptyLine = function () {",
        "\treturn (new ParseNode ({type: ParseNode.typeEmptyLine}));",
        "};",
        "ParseNode.createEnv = function (textOpen, textClose) {",
        "\treturn (new ParseNode ({type: ParseNode.typeEnv, textOpen: textOpen, textClose: textClose, children: []}));",
        "};",
        "ParseNode.createEnvBegin = function (envName, text) {",
        "\treturn (new ParseNode ({type: ParseNode.typeEnvBegin, envName: envName, text: text}));",
        "};",
        "ParseNode.createEnvEnd = function (envName, text) {",
        "\treturn (new ParseNode ({type: ParseNode.typeEnvEnd, envName: envName, text: text}));",
        "};",
        "ParseNode.createRoot = function () {",
        "\treturn (new ParseNode ({type: ParseNode.typeRoot, children: []}));",
        "};",
        "ParseNode.createText = function (text) {",
        "\treturn (new ParseNode ({type: ParseNode.typeText, text: text}));",
        "};",
        "ParseNode.createVerbatim = function (text) {",
        "\treturn (new ParseNode ({type: ParseNode.typeVerbatim, text: text}));",
        "};",
        "",
        "// Class ParseTree",
        "",
        "function ParseTree (document)",
        "{",
        "\tthis.indentString = ParseTree._priv_getIndentString ();",
        "\tthis.eolString = document.lineEndingString ();",
        "\tthis._priv_parseDocument (document);",
        "}",
        "ParseTree.prototype = {",
        "\t_priv_parseDocument: function (document) {",
        "\t\tvar initial, linearNodes;",
        "",
        "\t\tinitial = ParseTree._priv_parseTxsTokensAndText (document);",
        "\t\tlinearNodes = ParseTree._priv_parseCombinedLinear (initial.tokens, initial.text);",
        "\t\tthis.root = ParseTree._priv_parseCombinedTree (linearNodes);",
        "\t},",
        "",
        "\tbuildText: function () {",
        "\t\treturn (this._priv_buildNode (this.root, ''));",
        "\t},",
        "",
        "\t_priv_buildNode: function (node, indentPrefix) {",
        "\t\tswitch (node.type) {",
        "\t\tcase ParseNode.typeComment:",
        "\t\tcase ParseNode.typeText:",
        "\t\tcase ParseNode.typeVerbatim:",
        "\t\t\treturn (indentPrefix + node.text + this.eolString);",
        "\t\tcase ParseNode.typeEmptyLine:",
        "\t\t\treturn (this.eolString);",
        "\t\tcase ParseNode.typeEnv:",
        "\t\t\treturn (",
        "\t\t\t\tindentPrefix + node.textOpen + this.eolString +",
        "\t\t\t\tthis._priv_buildChildren (node, this.indentString + indentPrefix) +",
        "\t\t\t\tindentPrefix + node.textClose + this.eolString",
        "\t\t\t);",
        "\t\tcase ParseNode.typeRoot:",
        "\t\t\treturn (this._priv_buildChildren (node, indentPrefix));",
        "\t\tdefault:",
        "\t\t\tfatal_error ('Unsupported node type');",
        "\t\t}",
        "\t},",
        "",
        "\t_priv_buildChildren: function (node, indentPrefix) {",
        "\t\tvar result, i, n;",
        "",
        "\t\tresult = '';",
        "\t\tfor (i = 0, n = node.children.length; i < n; ++i) {",
        "\t\t\tresult += this._priv_buildNode (node.children [i], indentPrefix);",
        "\t\t}",
        "\t\treturn (result);",
        "\t}",
        "};",
        "ParseTree._priv_getIndentString = function () {",
        "\tvar result, tabStop, i;",
        "",
        "\tif (ParseTree._priv_getSetting ('Editor\\Indent%20with%20Spaces') == 'true') {",
        "\t\tresult = '';",
        "\t\ttabStop = parseInt (getPersistent ('Editor\\TabStop'));",
        "\t\tfor (i = 0; i < tabStop; ++i) {",
        "\t\t\tresult += ' ';",
        "\t\t}",
        "\t} else {",
        "\t\tresult = \"\\t\";",
        "\t}",
        "\treturn (result);",
        "};",
        "ParseTree._priv_getSetting = function (name) {",
        "\tvar value;",
        "",
        "\tif ((value = getPersistent (name)) === null) {",
        "\t\tfatal_error ('Missing setting \\'' + name + '\\' or access is denied');",
        "\t}",
        "\treturn (value);",
        "",
        "};",
        "ParseTree._priv_parseTxsTokensAndText = function (document) {",
        "\tvar documentTokens, documentText, lines, lineOffset, i, lineTokens, j, oneLineToken;",
        "",
        "\tdocumentTokens = [];",
        "\tdocumentText = '';",
        "\tlines = document.textLines ();",
        "\t// When the last line ends with an EOL, TXS adds an extra empty line to the lines array",
        "\tif (lines.length && (lines [lines.length-1] == '')) {",
        "\t\tlines.pop ();",
        "\t}",
        "\tlineOffset = 0;",
        "\tfor (i = 0; i < lines.length; ++i) {",
        "\t\tif ((lineTokens = document.getLineTokens (i)) === false) {",
        "\t\t\tfatal_error ('Line ' + i + ' does not have parse information');",
        "\t\t}",
        "\t\tfor (j = 0; j < lineTokens.length; ++j) {",
        "\t\t\toneLineToken = lineTokens [j];",
        "\t\t\tdocumentTokens.push ({",
        "\t\t\t\ttype: oneLineToken.type,",
        "\t\t\t\tsubtype: oneLineToken.subtype,",
        "\t\t\t\tlevel: oneLineToken.level,",
        "\t\t\t\toffset: lineOffset + oneLineToken.startColumn,",
        "\t\t\t\ttext: oneLineToken.text",
        "\t\t\t});",
        "\t\t}",
        "\t\tdocumentText += lines [i] + '\\n';",
        "\t\tlineOffset += lines [i].length + 1;",
        "\t}",
        "\treturn ({tokens: documentTokens, text: documentText});",
        "};",
        "ParseTree._priv_parseCombinedLinear = function (txsTokens, text) {",
        "\tvar linearNodes, textStart, txsIndex, oneTxsToken, envName, verbatimEnd;",
        "",
        "\tlinearNodes = [];",
        "\ttextStart = 0;",
        "\ttxsIndex = 0;",
        "\twhile (txsIndex < txsTokens.length) {",
        "\t\toneTxsToken = txsTokens [txsIndex];",
        "\t\tswitch (oneTxsToken.type) {",
        "\t\tcase latexTokenType.beginEnv:",
        "\t\t\tcommandInfo = ParseTree._priv_getCommandInfo (txsTokens, txsIndex);",
        "\t\t\tif (textStart < commandInfo.textStart) {",
        "\t\t\t\tParseTree._priv_parseCombinedText (linearNodes, text.substring (textStart, commandInfo.textStart));",
        "\t\t\t}",
        "\t\t\tenvName = oneTxsToken.text;",
        "\t\t\tif (envName == \"verbatim\") {",
        "\t\t\t\tverbatimEnd = ParseTree._priv_parseFindVerbatimEnd (txsTokens, txsIndex + 1);",
        "\t\t\t\tlinearNodes.push (ParseNode.createVerbatim (",
        "\t\t\t\t\ttext.substring (commandInfo.textStart, verbatimEnd.textEnd)",
        "\t\t\t\t))",
        "\t\t\t\ttextStart = verbatimEnd.textEnd;",
        "\t\t\t\ttxsIndex = verbatimEnd.nextTokenIndex;",
        "\t\t\t} else {",
        "\t\t\t\ttextStart = commandInfo.textEnd;",
        "\t\t\t\tlinearNodes.push (ParseNode.createEnvBegin (",
        "\t\t\t\t\tenvName,",
        "\t\t\t\t\ttext.substring (commandInfo.textStart, commandInfo.textEnd)",
        "\t\t\t\t))",
        "\t\t\t\ttxsIndex = commandInfo.nextTokenIndex;",
        "\t\t\t}",
        "\t\t\tbreak;",
        "\t\tcase latexTokenType.env:",
        "\t\t\tcommandInfo = ParseTree._priv_getCommandInfo (txsTokens, txsIndex);",
        "\t\t\tif (textStart < commandInfo.textStart) {",
        "\t\t\t\tParseTree._priv_parseCombinedText (linearNodes, text.substring (textStart, commandInfo.textStart));",
        "\t\t\t}",
        "\t\t\ttextStart = commandInfo.textEnd;",
        "\t\t\tlinearNodes.push (ParseNode.createEnvEnd (",
        "\t\t\t\ttxsTokens [txsIndex].text,",
        "\t\t\t\ttext.substring (commandInfo.textStart, commandInfo.textEnd)",
        "\t\t\t))",
        "\t\t\ttxsIndex = commandInfo.nextTokenIndex;",
        "\t\t\tbreak;",
        "\t\tdefault:",
        "\t\t\t++txsIndex;",
        "\t\t\tbreak;",
        "\t\t}",
        "\t}",
        "\tif (textStart < text.length) {",
        "\t\tParseTree._priv_parseCombinedText (linearNodes, text.substring (textStart));",
        "\t}",
        "\treturn (linearNodes);",
        "};",
        "ParseTree._priv_parseFindVerbatimEnd = function (txsTokens, startIndex) {",
        "\tvar index, oneTxsToken;",
        "",
        "\tfor (index = startIndex; index < txsTokens.length; ++index) {",
        "\t\toneTxsToken = txsTokens [index];",
        "\t\tif ((oneTxsToken.type == latexTokenType.env) && (oneTxsToken.text == \"verbatim\")) {",
        "\t\t\treturn (ParseTree._priv_getCommandInfo (txsTokens, index));",
        "\t\t}",
        "\t}",
        "\tfatal_error (\"Could not find \\\\end{verbatim}\");",
        "};",
        "ParseTree._priv_getCommandInfo = function (txsTokens, indexArg) {",
        "\tvar indexFirst, indexLast, textStart, textEnd, i, newStart, newEnd;",
        "",
        "\tindexFirst = ParseTree._priv_getCommandFirst (txsTokens, indexArg);",
        "\tindexLast = ParseTree._priv_getCommandLast (txsTokens, indexFirst);",
        "\t/*",
        "\t\tToken ends do not increase monotonically, e.g. \\begin{document}",
        "\t\tis represented by \\begin, {document}, document",
        "\t\tThat is why we have to check each token for leftmost/rightmost",
        "\t\tpostition in text.",
        "\t*/",
        "\ttextStart = null;",
        "\ttextEnd = null;",
        "\tfor (i = indexFirst; i <= indexLast; ++i) {",
        "\t\tnewStart = txsTokens [i].offset;",
        "\t\tnewEnd = newStart + txsTokens [i].text.length;",
        "\t\tif ((textStart === null) || (newStart < textStart)) {",
        "\t\t\ttextStart = newStart;",
        "\t\t}",
        "\t\tif ((textEnd === null) || (newEnd > textEnd)) {",
        "\t\t\ttextEnd = newEnd;",
        "\t\t}",
        "\t}",
        "\treturn ({",
        "\t\ttextStart: textStart,",
        "\t\ttextEnd: textEnd,",
        "\t\tnextTokenIndex: indexLast + 1",
        "\t});",
        "};",
        "ParseTree._priv_getCommandFirst = function (txsTokens, indexArg) {",
        "\tvar argLevel, indexFirst, oneToken;",
        "",
        "\targLevel = txsTokens [indexArg].level;",
        "\tfor (indexFirst = indexArg - 1;;--indexFirst) {",
        "\t\tif (indexFirst < 0) {",
        "\t\t\tbreak;",
        "\t\t}",
        "\t\toneToken = txsTokens [indexFirst];",
        "\t\tif (oneToken.level < argLevel) {",
        "\t\t\tif (oneToken.level != argLevel - 1) {",
        "\t\t\t\tbreak;",
        "\t\t\t}",
        "\t\t\tif (oneToken.type != latexTokenType.command) {",
        "\t\t\t\tbreak;",
        "\t\t\t}",
        "\t\t\treturn (indexFirst);",
        "\t\t}",
        "\t}",
        "\tfatal_error ('Could not find command for argument ' + txsTokens [indexArg].text);",
        "};",
        "ParseTree._priv_getCommandLast = function (txsTokens, indexFirst) {",
        "\tvar commandLevel, indexLast;",
        "",
        "\tcommandLevel = txsTokens [indexFirst].level;",
        "\tfor (indexLast = indexFirst + 1; indexLast < txsTokens.length; ++indexLast) {",
        "\t\tif (txsTokens [indexLast].level <= commandLevel) {",
        "\t\t\tbreak;",
        "\t\t}",
        "\t}",
        "\t--indexLast;",
        "\treturn (indexLast);",
        "};",
        "ParseTree._priv_parseCombinedText = function (linearNodes, text) {",
        "\tvar tryCreateText = function (textStart, textEnd) {",
        "\t\tvar output;",
        "",
        "\t\tif (textStart == textEnd) {",
        "\t\t\treturn;",
        "\t\t}",
        "\t\toutput = text.substring (textStart, textEnd);",
        "\t\toutput = output.replace (/\\s+/g, ' ');",
        "\t\toutput = output.trim ();",
        "\t\tif (output.length == 0) {",
        "\t\t\treturn;",
        "\t\t}",
        "\t\tlinearNodes.push (ParseNode.createText (output));",
        "\t};",
        "",
        "\t/*",
        "\t\tThe TXS tokenizer does not provide the comment tokens (even though it has a comment token type),",
        "\t\tso we have to detect manually the comments. We also detect the empty lines (TeX paragraphs and",
        "\t\tturn them into typeEmptyLine nodes.",
        "\t*/",
        "\toffset = 0;",
        "\trx = /(\\n{2,})|%[^\\n]*/g;",
        "\trx.lastIndex = 0;",
        "\twhile ((match = rx.exec (text)) !== null) {",
        "\t\ttryCreateText (offset, match.index);",
        "\t\tswitch (match [0].charAt (0)) {",
        "\t\tcase '\\n':",
        "\t\t\tlinearNodes.push (ParseNode.createEmptyLine ());",
        "\t\t\tbreak;",
        "\t\tcase '%':",
        "\t\t\tlinearNodes.push (ParseNode.createComment (match [0]));",
        "\t\t\tbreak;",
        "\t\tdefault:",
        "\t\t\tfatal_error ('Unknown match type');",
        "\t\t}",
        "\t\toffset = match.index + match [0].length;",
        "\t}",
        "\ttryCreateText (offset, text.length);",
        "};",
        "ParseTree._priv_parseCombinedTree = function (linearNodes) {",
        "\tvar root;",
        "",
        "\troot = ParseNode.createRoot ();",
        "\tParseTree._priv_parseCombinedTreeChildren (root, linearNodes, 0, linearNodes.length);",
        "\treturn (root);",
        "};",
        "ParseTree._priv_parseCombinedTreeChildren = function (parent, linearNodes, indexBegin, indexEnd) {",
        "\tvar i, j, linearToken, treeToken;",
        "",
        "\ti = indexBegin;",
        "\twhile (i < indexEnd) {",
        "\t\tlinearToken = linearNodes [i];",
        "\t\tswitch (linearToken.type) {",
        "\t\tcase ParseNode.typeEnvBegin:",
        "\t\t\tj = ParseTree._priv_parseCombinedTreeFindEnvEnd (linearNodes, i, indexEnd);",
        "\t\t\ttreeToken = ParseNode.createEnv (linearNodes [i].text, linearNodes [j].text);",
        "\t\t\tParseTree._priv_parseCombinedTreeChildren (treeToken, linearNodes, i+1, j);",
        "\t\t\tparent.addChild (treeToken);",
        "\t\t\ti = j + 1;",
        "\t\t\tbreak;",
        "\t\tcase ParseNode.typeEnvEnd:",
        "\t\t\tfatal_error ('Unexpected environment end');",
        "\t\tdefault:",
        "\t\t\tparent.addChild (linearToken);",
        "\t\t\t++i;",
        "\t\t\tbreak;",
        "\t\t}",
        "\t}",
        "};",
        "ParseTree._priv_parseCombinedTreeFindEnvEnd = function (linearNodes, indexBegin, indexLimit) {",
        "\tvar envName, depth, indexEnd, oneNode;",
        "",
        "\tenvName = linearNodes [indexBegin].envName;",
        "\tdepth = 1;",
        "\tfor (indexEnd = indexBegin + 1; indexEnd < indexLimit; ++indexEnd) {",
        "\t\toneNode = linearNodes [indexEnd];",
        "\t\tif ((oneNode.type == ParseNode.typeEnvBegin) && (oneNode.envName == envName)) {",
        "\t\t\t++depth;",
        "\t\t} else if ((oneNode.type == ParseNode.typeEnvEnd) && (oneNode.envName == envName)) {",
        "\t\t\tif (--depth == 0) {",
        "\t\t\t\treturn (indexEnd);",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "\tfatal_error ('Could not find environment end');",
        "};",
        "",
        "// Global code",
        "",
        "if (typeof (editor) == 'undefined') {",
        "\tfatal_error ('No open editor');",
        "}",
        "tree = new ParseTree (editor.document ());",
        "newText = tree.buildText ();",
        "editor.setText (newText);",
        ""
    ],
    "trigger": ""
}
